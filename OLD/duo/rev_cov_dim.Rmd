---
title: "Reverse coverage-based hub definition"
output: html_document
---

```{r load data, include = FALSE}
library(pbapply)
source(file="/Users/elise/Desktop/GitHub/Hubness_sc/R_scripts/load_data/hubness_load_write_data_duo.R")
hubness <- pblapply(1:length(hubness),
                    function(x) {hubness[[x]]$cellID <- names(hubness_scores_data[[x]][[1]][[1]]);
                    return(hubness[[x]])})
source(file="/Users/elise/Desktop/GitHub/Hubness_sc/R_scripts/load_data/load_counts_duo.R")

source(file="/Users/elise/Desktop/GitHub/Hubness_sc/R_scripts/load_data/load_functions.R")
```

```{r get hub scores, include=FALSE}
hub_scores <- pblapply(1:length(hubness),
                       function(x) hubness[[x]]$score[hubness[[x]]$Dimension==(cell_nb[x]-1) & hubness[[x]]$p==2 & hubness[[x]]$k==50])
hub_scores <- pblapply(1:length(hub_scores),
                       function(x) {names(hub_scores[[x]]) <- names(hubness_scores_data[[x]][[1]][[1]]);
                       return(hub_scores[[x]])})
```

```{r get rev cov hubs as a fn of dim, include=FALSE}
hub_nb_dim<- function(data,d,hub_scores,thd, n_cell) {
  k <- min(50,round(ncol(data)/20))
  neighbors <- findKNN(t(data[1:d,]), k)
  neighbor_list <- neighbors$index
  rownames(neighbor_list) <- colnames(data)
  h_nb <- reverse_coverage_k(neighbor_list, hub_scores, k, thd, n_cell)
  return(h_nb)
}
```

```{r get numbers, include=FALSE}
dim_val <- pblapply(dim_nb,
                    function(x) c(2,5,10,20,30,40,50,100,x))
hb_nb <- pblapply(1:length(data_pca),
                  function(y) sapply(dim_val[[y]],
                                     function(x) {tmp<-hub_nb_dim(data_pca[[y]],x,hub_scores[[y]],1, cell_nb[y]);
                                     return(tmp)}))
```

```{r reverse coverage hubs as a function of the dimension}
df <- data.frame("Dataset"=rep(dataset,each=length(dim_val[[1]])),
                 "Dimension"=unlist(dim_val),
                 "Hub_nb"=unlist(hb_nb))
ggplot(df, aes(x=Dimension, y=Hub_nb, color=Dataset)) + geom_line(aes(group=Dataset)) + geom_point()
```

```{r rev cov def}
reverse_coverage_random_k <- function(neighbor_list, k, n_cell) {
  cell_randomized <- sample(rownames(neighbor_list),nrow(neighbor_list))
  random_cell_nb <- 10
  random_cells <- cell_randomized[1:random_cell_nb]
  coverage <- sum(apply(neighbor_list[,1:k],1,function(x) any(x %in% random_cells)))
  while (tail(coverage,n=1) < n_cell*0.9 & random_cell_nb < 1000) {
    random_cell_nb <- random_cell_nb+10
    random_cells <- cell_randomized[1:random_cell_nb]
    coverage <- c(coverage, sum(apply(neighbor_list[,1:k],1,function(x) any(x %in% random_cells))))
  }
  return(list(coverage=coverage,random_cell_nb=random_cell_nb))
}
plateau_detection <- function(neighbor_list, hub_scores, k, thd, n_cell) {
  cell_scores_sorted <- order(hub_scores, decreasing=T)
  hub_nb <- 10
  hubs <- cell_scores_sorted[1:hub_nb]
  coverage <- sum(apply(neighbor_list[,1:k],1,function(x) any(x %in% hubs)))/n_cell*100
  plateau <- integer(0)
  while (tail(coverage,n=1) < n_cell*0.9 & hub_nb < 1000 & length(plateau)==0) {
    hub_nb <- hub_nb+10
    hubs <- cell_scores_sorted[1:hub_nb]
    coverage <- c(coverage, sum(apply(neighbor_list[,1:k],1,function(x) any(x %in% hubs)))/n_cell*100)
    increment <- diff(coverage[2:length(coverage)])
    plateau <- which(increment<=thd)
  }
  plateau <- plateau[1]+1
  rev_coverage_rdm <- reverse_coverage_random_k(neighbor_list, k, n_cell)
  plot(seq(10,hub_nb,10),coverage/n_cell*100, ylim=c(0,100),
       pch=16,
       xlab="Number of hubs",
       ylab="Reverse coverage (%)",
       main=paste0("Reverse coverage of the data looking at ",k," neighbors"))
  points(seq(10,rev_coverage_rdm$random_cell_nb,10),rev_coverage_rdm$coverage/n_cell*100, col="lightblue", pch=3)
  abline(h=90, col='red', lty='dashed')
  abline(v=rev_coverage_rdm$random_cell_nb, col="lightblue", lty="dotted")
  abline(v=hub_nb, col="orange")
  return(hub_nb)
}
hub_nb_dim<- function(data,d,k,hub_scores,thd, n_cell) {
  neighbors <- findKNN(t(data[1:d,]), k)
  neighbor_list <- neighbors$index
  rownames(neighbor_list) <- colnames(data)
  h_nb <- plateau_detection(neighbor_list, hub_scores, k, thd, n_cell)
  return(h_nb)
}

pblapply(1:length(data_pca), function(x) hub_nb_dim(data_pca[[x]], 100, hub_scores[[x]], 0.01, cell_nb[x]))
```

